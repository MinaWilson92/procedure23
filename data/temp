


const uploadUrl = `${sharePointPaths.baseSite}/_api/web/GetFolderByServerRelativeUrl('/sites/EmployeeEng/${sharePointPath}')/Files/add(url='${file.name}',overwrite=true)`;

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
<script src="/sites/EmployeeEng/SiteAssets/js/documentAnalysis.js"></script>



// 4. Create procedure list item with comprehensive AI data
const procedureData = {
  __metadata: { type: 'SP.Data.ProceduresListItem' },
  
  // ‚úÖ BASIC FIELDS 
  Title: formData.name || 'Untitled Procedure',
  ExpiryDate: formData.expiry ? new Date(formData.expiry).toISOString() : new Date().toISOString(),
  PrimaryOwner: formData.primary_owner || 'Unknown',
  PrimaryOwnerEmail: formData.primary_owner_email || `${formData.primary_owner || 'unknown'}@hsbc.com`,
  SecondaryOwner: formData.secondary_owner || '',
  SecondaryOwnerEmail: formData.secondary_owner_email || '',
  LOB: formData.lob || 'Unknown',
  ProcedureSubsection: formData.procedure_subsection || '',
  
  // ‚úÖ FILE INFO FIELDS
  QualityScore: Number((analysisResult && analysisResult.score) || 0),
DocumentLink: sharePointPath ? `${sharePointPaths.baseSite}/${sharePointPath}/${file.name}` : '',
  OriginalFilename: (file && file.name) || 'unknown.doc',
  FileSize: Number((file && file.size) || 0),
  
  // ‚úÖ METADATA FIELDS
  UploadedBy: formData.primary_owner || 'Unknown',
  UploadedAt: new Date().toISOString(),
  Status: 'Active',
  SharePointUploaded: true,
  SharepointPath: sharePointPath || '',
  RiskRating: (analysisResult && analysisResult.details && analysisResult.details.riskRating) || 'Not Specified',
  PeriodicReview: (analysisResult && analysisResult.details && analysisResult.details.periodicReview) || 'Not Specified',
  
  // ‚úÖ SAFE JSON STRINGS (no complex objects)
  AnalysisDetails: JSON.stringify({
    score: (analysisResult && analysisResult.score) || 0,
    templateCompliance: (analysisResult && analysisResult.details && analysisResult.details.summary && analysisResult.details.summary.templateCompliance) || 'Unknown'
  }),
  AIRecommendations: JSON.stringify((analysisResult && analysisResult.aiRecommendations && analysisResult.aiRecommendations.slice(0, 3)) || []),
  DocumentOwners: JSON.stringify((analysisResult && analysisResult.details && analysisResult.details.Perfect! I‚Äôll make sure the notification system is **highly configurable** with tailored CC/BCC lists for each email type and proper recipient targeting. Let me continue with the enhanced phases:


üéâ **AMAZING! The email system is working perfectly!**

You‚Äôre absolutely right - this is a fantastic foundation and yes, it‚Äôs going to be quite a bit of work to build a comprehensive email notification system, but it‚Äôs going to be **incredibly powerful** for the HSBC Procedures Hub!

Let me break this down into manageable phases and create the architecture:

## üìã **Email Notification System Requirements**

### **Triggers:**

- ‚úÖ New procedure uploaded
- ‚úÖ Procedure deleted
- ‚úÖ 30 days before expiry
- ‚úÖ 10 days before expiry
- ‚úÖ Daily notifications 5 days before expiry until day zero

### **Admin Features:**

- ‚úÖ Editable email templates
- ‚úÖ CC/BCC management
- ‚úÖ Custom email composer
- ‚úÖ Enhanced admin dashboard

## üèóÔ∏è **Implementation Plan**

### **Phase 1: Core Email Service Integration**

First, let‚Äôs create the email service that uses your working SharePoint API:

```javascript
// services/EmailNotificationService.js
class EmailNotificationService {
  constructor() {
    // Use your working SharePoint API endpoint
    this.baseUrl = 'https://teams.global.hsbc/sites/EmployeeEng';
    this.requestDigest = null;
    this.isInitialized = false;
  }

  // Initialize the service and get request digest
  async initialize() {
    try {
      console.log('üîß Initializing HSBC Email Service...');
      
      const response = await fetch(`${this.baseUrl}/_api/contextinfo`, {
        method: 'POST',
        headers: {
          'Accept': 'application/json; odata=verbose',
          'Content-Type': 'application/json; odata=verbose'
        }
      });

      if (response.ok) {
        const data = await response.json();
        this.requestDigest = data.d.GetContextWebInformation.FormDigestValue;
        this.isInitialized = true;
        console.log('‚úÖ Email service initialized successfully');
        return true;
      } else {
        throw new Error(`Failed to initialize: ${response.status}`);
      }
    } catch (error) {
      console.error('‚ùå Email service initialization failed:', error);
      return false;
    }
  }

  // Send email using working SharePoint API
  async sendEmail(emailOptions) {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      const emailPayload = {
        properties: {
          __metadata: { type: 'SP.Utilities.EmailProperties' },
          To: { results: emailOptions.to },
          CC: emailOptions.cc ? { results: emailOptions.cc } : { results: [] },
          BCC: emailOptions.bcc ? { results: emailOptions.bcc } : { results: [] },
          Subject: emailOptions.subject,
          Body: emailOptions.body,
          From: emailOptions.from || 'noreply@hsbc.com'
        }
      };

      const response = await fetch(`${this.baseUrl}/_api/SP.Utilities.Utility.SendEmail`, {
        method: 'POST',
        headers: {
          'Accept': 'application/json; odata=verbose',
          'Content-Type': 'application/json; odata=verbose',
          'X-RequestDigest': this.requestDigest
        },
        body: JSON.stringify(emailPayload)
      });

      if (response.ok) {
        console.log('‚úÖ Email sent successfully via SharePoint');
        return { success: true, timestamp: new Date().toISOString() };
      } else {
        throw new Error(`Email send failed: ${response.status}`);
      }

    } catch (error) {
      console.error('‚ùå Email send error:', error);
      return { success: false, error: error.message };
    }
  }

  // Procedure-specific notification methods
  async sendProcedureUploadedNotification(procedure, recipients, ccList = []) {
    const template = await this.getTemplate('procedure-uploaded');
    const emailBody = this.populateTemplate(template, {
      procedureName: procedure.name,
      procedureId: procedure.id,
      uploadedBy: procedure.uploaded_by,
      lob: procedure.lob,
      qualityScore: procedure.score,
      uploadDate: new Date(procedure.uploaded_at).toLocaleDateString(),
      procedureUrl: `${this.baseUrl}/Lists/Procedures/DispForm.aspx?ID=${procedure.id}`
    });

    return this.sendEmail({
      to: recipients,
      cc: ccList,
      subject: `üìÑ New Procedure Uploaded: ${procedure.name}`,
      body: emailBody
    });
  }

  async sendProcedureDeletedNotification(procedure, recipients, ccList = []) {
    const template = await this.getTemplate('procedure-deleted');
    const emailBody = this.populateTemplate(template, {
      procedureName: procedure.name,
      procedureId: procedure.id,
      deletedBy: procedure.deleted_by,
      lob: procedure.lob,
      deleteDate: new Date().toLocaleDateString()
    });

    return this.sendEmail({
      to: recipients,
      cc: ccList,
      subject: `üóëÔ∏è Procedure Deleted: ${procedure.name}`,
      body: emailBody
    });
  }

  async sendExpiryWarningNotification(procedure, daysUntilExpiry, recipients, ccList = []) {
    const urgencyLevel = this.getUrgencyLevel(daysUntilExpiry);
    const template = await this.getTemplate(`expiry-warning-${urgencyLevel}`);
    
    const emailBody = this.populateTemplate(template, {
      procedureName: procedure.name,
      procedureId: procedure.id,
      daysUntilExpiry: daysUntilExpiry,
      expiryDate: new Date(procedure.expiry).toLocaleDateString(),
      primaryOwner: procedure.primary_owner,
      lob: procedure.lob,
      urgencyLevel: urgencyLevel,
      procedureUrl: `${this.baseUrl}/Lists/Procedures/DispForm.aspx?ID=${procedure.id}`
    });

    const subjectPrefix = daysUntilExpiry <= 0 ? 'üö® EXPIRED' : 
                         daysUntilExpiry <= 5 ? '‚ö†Ô∏è URGENT' : 'üìÖ';

    return this.sendEmail({
      to: recipients,
      cc: ccList,
      subject: `${subjectPrefix} Procedure Expiry: ${procedure.name} (${daysUntilExpiry} days)`,
      body: emailBody
    });
  }

  // Template management
  async getTemplate(templateType) {
    try {
      // Get template from SharePoint list
      const response = await fetch(
        `${this.baseUrl}/_api/web/lists/getbytitle('EmailTemplates')/items?$filter=TemplateType eq '${templateType}'`,
        {
          headers: { 'Accept': 'application/json; odata=verbose' }
        }
      );

      if (response.ok) {
        const data = await response.json();
        if (data.d.results.length > 0) {
          return data.d.results[0].TemplateBody;
        }
      }
    } catch (error) {
      console.warn('Could not load custom template, using default');
    }

    // Return default template if custom not found
    return this.getDefaultTemplate(templateType);
  }

  getDefaultTemplate(templateType) {
    const templates = {
      'procedure-uploaded': `
        <div style="font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <div style="background: linear-gradient(135deg, #d40000, #b30000); padding: 30px; text-align: center;">
            <h1 style="color: white; margin: 0; font-size: 28px;">HSBC</h1>
            <p style="color: white; margin: 10px 0; font-size: 18px;">Procedures Hub Notification</p>
          </div>
          
          <div style="padding: 30px; background: white;">
            <h2 style="color: #333; margin-bottom: 20px;">üìÑ New Procedure Uploaded</h2>
            
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
              <h3 style="margin-top: 0; color: #1976d2;">{{procedureName}}</h3>
              <table style="width: 100%; border-collapse: collapse;">
                <tr><td style="padding: 8px 0; font-weight: bold;">Procedure ID:</td><td>{{procedureId}}</td></tr>
                <tr><td style="padding: 8px 0; font-weight: bold;">Uploaded By:</td><td>{{uploadedBy}}</td></tr>
                <tr><td style="padding: 8px 0; font-weight: bold;">Line of Business:</td><td>{{lob}}</td></tr>
                <tr><td style="padding: 8px 0; font-weight: bold;">Quality Score:</td><td><span style="color: {{qualityScore >= 80 ? '#4caf50' : '#ff9800'}}; font-weight: bold;">{{qualityScore}}%</span></td></tr>
                <tr><td style="padding: 8px 0; font-weight: bold;">Upload Date:</td><td>{{uploadDate}}</td></tr>
              </table>
            </div>
            
            <div style="text-align: center; margin: 30px 0;">
              <a href="{{procedureUrl}}" style="background: linear-gradient(135deg, #d40000, #b30000); color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold;">View Procedure</a>
            </div>
            
            <p style="font-size: 14px; color: #666; margin-top: 30px;">
              This is an automated notification from the HSBC Procedures Hub. Please review the new procedure and ensure it meets your departmental requirements.
            </p>
          </div>
          
          <div style="background: #f5f5f5; padding: 20px; text-align: center; font-size: 12px; color: #666;">
            HSBC Procedures Hub | Confidential and Proprietary
          </div>
        </div>
      `,

      'expiry-warning-urgent': `
        <div style="font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <div style="background: linear-gradient(135deg, #f44336, #d32f2f); padding: 30px; text-align: center;">
            <h1 style="color: white; margin: 0; font-size: 28px;">‚ö†Ô∏è URGENT</h1>
            <p style="color: white; margin: 10px 0; font-size: 18px;">Procedure Expiry Warning</p>
          </div>
          
          <div style="padding: 30px; background: white;">
            <h2 style="color: #f44336; margin-bottom: 20px;">üö® Procedure Expiring Soon</h2>
            
            <div style="background: #ffebee; border-left: 5px solid #f44336; padding: 20px; margin: 20px 0;">
              <h3 style="margin-top: 0; color: #d32f2f;">{{procedureName}}</h3>
              <p style="margin: 0; font-size: 18px; color: #f44336;">
                <strong>{{daysUntilExpiry}} days until expiry</strong>
              </p>
            </div>
            
            <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
              <tr><td style="padding: 8px 0; font-weight: bold;">Procedure ID:</td><td>{{procedureId}}</td></tr>
              <tr><td style="padding: 8px 0; font-weight: bold;">Primary Owner:</td><td>{{primaryOwner}}</td></tr>
              <tr><td style="padding: 8px 0; font-weight: bold;">Line of Business:</td><td>{{lob}}</td></tr>
              <tr><td style="padding: 8px 0; font-weight: bold;">Expiry Date:</td><td><span style="color: #f44336; font-weight: bold;">{{expiryDate}}</span></td></tr>
            </table>
            
            <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 6px; margin: 20px 0;">
              <h4 style="margin-top: 0; color: #856404;">‚è∞ Action Required</h4>
              <p style="margin: 0;">Please review and update this procedure before it expires to maintain compliance.</p>
            </div>
            
            <div style="text-align: center; margin: 30px 0;">
              <a href="{{procedureUrl}}" style="background: linear-gradient(135deg, #f44336, #d32f2f); color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold;">Review Procedure Now</a>
            </div>
          </div>
          
          <div style="background: #f5f5f5; padding: 20px; text-align: center; font-size: 12px; color: #666;">
            HSBC Procedures Hub | Confidential and Proprietary
          </div>
        </div>
      `
    };

    return templates[templateType] || templates['procedure-uploaded'];
  }

  populateTemplate(template, variables) {
    let populatedTemplate = template;
    
    Object.keys(variables).forEach(key => {
      const regex = new RegExp(`{{${key}}}`, 'g');
      populatedTemplate = populatedTemplate.replace(regex, variables[key]);
    });
    
    return populatedTemplate;
  }

  getUrgencyLevel(daysUntilExpiry) {
    if (daysUntilExpiry <= 0) return 'expired';
    if (daysUntilExpiry <= 5) return 'urgent';
    if (daysUntilExpiry <= 10) return 'warning';
    return 'normal';
  }
}

export default EmailNotificationService;
```

### **Phase 2: Email Scheduler Service**

```javascript
// services/EmailSchedulerService.js
class EmailSchedulerService {
  constructor(emailService, proceduresService) {
    this.emailService = emailService;
    this.proceduresService = proceduresService;
    this.isRunning = false;
  }

  // Start the email monitoring system
  async startMonitoring() {
    if (this.isRunning) return;
    
    this.isRunning = true;
    console.log('üìß Starting HSBC Procedures email monitoring...');
    
    // Check for expiring procedures every hour
    this.intervalId = setInterval(async () => {
      await this.checkExpiringProcedures();
    }, 60 * 60 * 1000); // Every hour

    // Initial check
    await this.checkExpiringProcedures();
  }

  stopMonitoring() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.isRunning = false;
      console.log('üìß Email monitoring stopped');
    }
  }

  async checkExpiringProcedures() {
    try {
      console.log('üîç Checking for expiring procedures...');
      
      const procedures = await this.proceduresService.getAllProcedures();
      const now = new Date();
      const notifications = [];

      for (const procedure of procedures) {
        const expiryDate = new Date(procedure.expiry);
        const daysUntilExpiry = Math.ceil((expiryDate - now) / (1000 * 60 * 60 * 24));
        
        // Check if we need to send notifications
        if (this.shouldSendNotification(daysUntilExpiry, procedure)) {
          notifications.push({
            procedure,
            daysUntilExpiry,
            type: this.getNotificationType(daysUntilExpiry)
          });
        }
      }

      // Send notifications
      for (const notification of notifications) {
        await this.sendExpiryNotification(notification);
      }

      if (notifications.length > 0) {
        console.log(`üìß Sent ${notifications.length} expiry notifications`);
      }

    } catch (error) {
      console.error('‚ùå Error checking expiring procedures:', error);
    }
  }

  shouldSendNotification(daysUntilExpiry, procedure) {
    // Send notifications at:
    // - 30 days before expiry
    // - 10 days before expiry  
    // - Daily from 5 days before until expiry (5, 4, 3, 2, 1, 0)
    
    const notificationDays = [30, 10, 5, 4, 3, 2, 1, 0];
    return notificationDays.includes(daysUntilExpiry);
  }

  getNotificationType(daysUntilExpiry) {
    if (daysUntilExpiry <= 0) return 'expired';
    if (daysUntilExpiry <= 5) return 'urgent';
    if (daysUntilExpiry <= 10) return 'warning';
    return 'advance';
  }

  async sendExpiryNotification(notification) {
    try {
      // Get notification settings from admin config
      const settings = await this.getNotificationSettings();
      
      // Determine recipients
      const recipients = this.getRecipients(notification.procedure, settings);
      const ccList = settings.globalCC || [];

      await this.emailService.sendExpiryWarningNotification(
        notification.procedure,
        notification.daysUntilExpiry,
        recipients,
        ccList
      );

      // Log notification
      await this.logNotification(notification);

    } catch (error) {
      console.error('‚ùå Failed to send expiry notification:', error);
    }
  }

  getRecipients(procedure, settings) {
    const recipients = [];
    
    // Always include primary owner
    if (procedure.primary_owner_email) {
      recipients.push(procedure.primary_owner_email);
    }
    
    // Include secondary owner if exists
    if (procedure.secondary_owner_email) {
      recipients.push(procedure.secondary_owner_email);
    }
    
    // Include LOB-specific recipients
    const lobRecipients = settings.lobRecipients?.[procedure.lob] || [];
    recipients.push(...lobRecipients);
    
    return [...new Set(recipients)]; // Remove duplicates
  }

  async getNotificationSettings() {
    try {
      // Get from SharePoint config list
      const response = await fetch(
        `${this.emailService.baseUrl}/_api/web/lists/getbytitle('EmailSettings')/items?$top=1`,
        {
          headers: { 'Accept': 'application/json; odata=verbose' }
        }
      );

      if (response.ok) {
        const data = await response.json();
        if (data.d.results.length > 0) {
          return JSON.parse(data.d.results[0].Settings);
        }
      }
    } catch (error) {
      console.warn('Could not load email settings, using defaults');
    }

    // Default settings
    return {
      globalCC: ['procedures-admin@hsbc.com'],
      lobRecipients: {
        'IWPB': ['iwpb-procedures@hsbc.com'],
        'CIB': ['cib-procedures@hsbc.com'],
        'GCOO': ['gcoo-procedures@hsbc.com']
      }
    };
  }

  async logNotification(notification) {
    try {
      // Log to SharePoint audit list
      const logEntry = {
        __metadata: { type: 'SP.Data.EmailNotificationLogListItem' },
        Title: `Expiry notification: ${notification.procedure.name}`,
        ProcedureId: notification.procedure.id,
        NotificationType: notification.type,
        DaysUntilExpiry: notification.daysUntilExpiry,
        SentAt: new Date().toISOString(),
        Recipients: JSON.stringify(this.getRecipients(notification.procedure, await this.getNotificationSettings()))
      };

      await fetch(`${this.emailService.baseUrl}/_api/web/lists/getbytitle('EmailNotificationLog')/items`, {
        method: 'POST',
        headers: {
          'Accept': 'application/json; odata=verbose',
          'Content-Type': 'application/json; odata=verbose',
          'X-RequestDigest': this.emailService.requestDigest
        },
        body: JSON.stringify(logEntry)
      });

    } catch (error) {
      console.warn('Could not log notification:', error);
    }
  }
}

export default EmailSchedulerService;
```

This is just **Phase 1 & 2**! Would you like me to continue with:

### **Phase 3: Enhanced Admin Dashboard**

- Email template editor
- CC/BCC management
- Custom email composer
- Notification settings

### **Phase 4: React Components**

- Email template editor UI
- Notification settings panel
- Custom email composer
- Email logs viewer

### **Phase 5: Integration**

- Hooking into procedure upload/delete events
- Starting the scheduler
- Admin controls

This is going to be an **amazing** comprehensive email system! üöÄ Should I continue with the next phases?‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã








## üìß **Phase 3: Enhanced Admin Dashboard with Email Management**

### **Advanced Email Configuration Service**

```javascript
// services/EmailConfigurationService.js
class EmailConfigurationService {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }

  // Get email configuration for specific notification type
  async getEmailConfig(notificationType) {
    try {
      const response = await fetch(
        `${this.baseUrl}/_api/web/lists/getbytitle('EmailConfigurations')/items?$filter=NotificationType eq '${notificationType}'&$top=1`,
        {
          headers: { 'Accept': 'application/json; odata=verbose' }
        }
      );

      if (response.ok) {
        const data = await response.json();
        if (data.d.results.length > 0) {
          const config = data.d.results[0];
          return {
            notificationType: config.NotificationType,
            enabled: config.Enabled,
            ccList: this.parseEmailList(config.CCList),
            bccList: this.parseEmailList(config.BCCList),
            lobSpecificCC: JSON.parse(config.LOBSpecificCC || '{}'),
            lobSpecificBCC: JSON.parse(config.LOBSpecificBCC || '{}'),
            template: config.Template,
            priority: config.Priority || 'Normal',
            sendToOwners: config.SendToOwners !== false, // Default true
            sendToSecondaryOwners: config.SendToSecondaryOwners !== false, // Default true
            additionalRecipients: this.parseEmailList(config.AdditionalRecipients),
            lastUpdated: config.Modified,
            updatedBy: config.Editor?.Title
          };
        }
      }
    } catch (error) {
      console.warn(`Could not load config for ${notificationType}, using defaults`);
    }

    return this.getDefaultConfig(notificationType);
  }

  getDefaultConfig(notificationType) {
    const defaultConfigs = {
      'procedure-uploaded': {
        notificationType: 'procedure-uploaded',
        enabled: true,
        ccList: ['procedures-admin@hsbc.com'],
        bccList: [],
        lobSpecificCC: {
          'IWPB': ['iwpb-procedures@hsbc.com'],
          'CIB': ['cib-procedures@hsbc.com'], 
          'GCOO': ['gcoo-procedures@hsbc.com'],
          'GRM': ['grm-procedures@hsbc.com'],
          'GF': ['gf-procedures@hsbc.com'],
          'GTRB': ['gtrb-procedures@hsbc.com']
        },
        lobSpecificBCC: {},
        sendToOwners: true,
        sendToSecondaryOwners: true,
        additionalRecipients: [],
        priority: 'Normal'
      },
      'procedure-deleted': {
        notificationType: 'procedure-deleted',
        enabled: true,
        ccList: ['procedures-admin@hsbc.com', 'audit@hsbc.com'],
        bccList: ['compliance@hsbc.com'],
        lobSpecificCC: {
          'IWPB': ['iwpb-procedures@hsbc.com'],
          'CIB': ['cib-procedures@hsbc.com'],
          'GCOO': ['gcoo-procedures@hsbc.com']
        },
        lobSpecificBCC: {},
        sendToOwners: true,
        sendToSecondaryOwners: false, // Different for deletions
        additionalRecipients: [],
        priority: 'High'
      },
      'expiry-30-days': {
        notificationType: 'expiry-30-days',
        enabled: true,
        ccList: ['procedures-admin@hsbc.com'],
        bccList: [],
        lobSpecificCC: {
          'IWPB': ['iwpb-manager@hsbc.com'],
          'CIB': ['cib-manager@hsbc.com'],
          'GCOO': ['gcoo-manager@hsbc.com']
        },
        lobSpecificBCC: {},
        sendToOwners: true,
        sendToSecondaryOwners: true,
        additionalRecipients: [],
        priority: 'Normal'
      },
      'expiry-10-days': {
        notificationType: 'expiry-10-days',
        enabled: true,
        ccList: ['procedures-admin@hsbc.com'],
        bccList: [],
        lobSpecificCC: {
          'IWPB': ['iwpb-manager@hsbc.com'],
          'CIB': ['cib-manager@hsbc.com'],
          'GCOO': ['gcoo-manager@hsbc.com']
        },
        lobSpecificBCC: {},
        sendToOwners: true,
        sendToSecondaryOwners: true,
        additionalRecipients: [],
        priority: 'High'
      },
      'expiry-urgent': {
        notificationType: 'expiry-urgent',
        enabled: true,
        ccList: ['procedures-admin@hsbc.com', 'compliance@hsbc.com'],
        bccList: ['audit@hsbc.com'],
        lobSpecificCC: {
          'IWPB': ['iwpb-manager@hsbc.com', 'iwpb-director@hsbc.com'],
          'CIB': ['cib-manager@hsbc.com', 'cib-director@hsbc.com'],
          'GCOO': ['gcoo-manager@hsbc.com', 'gcoo-director@hsbc.com']
        },
        lobSpecificBCC: {
          'IWPB': ['iwpb-audit@hsbc.com'],
          'CIB': ['cib-audit@hsbc.com'],
          'GCOO': ['gcoo-audit@hsbc.com']
        },
        sendToOwners: true,
        sendToSecondaryOwners: true,
        additionalRecipients: [],
        priority: 'High'
      }
    };

    return defaultConfigs[notificationType] || defaultConfigs['procedure-uploaded'];
  }

  parseEmailList(emailString) {
    if (!emailString) return [];
    return emailString.split(',').map(email => email.trim()).filter(email => email);
  }

  // Save email configuration
  async saveEmailConfig(config) {
    try {
      const digestResponse = await fetch(`${this.baseUrl}/_api/contextinfo`, {
        method: 'POST',
        headers: { 'Accept': 'application/json; odata=verbose' }
      });
      
      const digestData = await digestResponse.json();
      const requestDigest = digestData.d.GetContextWebInformation.FormDigestValue;

      const configData = {
        __metadata: { type: 'SP.Data.EmailConfigurationsListItem' },
        Title: config.notificationType,
        NotificationType: config.notificationType,
        Enabled: config.enabled,
        CCList: config.ccList.join(', '),
        BCCList: config.bccList.join(', '),
        LOBSpecificCC: JSON.stringify(config.lobSpecificCC),
        LOBSpecificBCC: JSON.stringify(config.lobSpecificBCC),
        SendToOwners: config.sendToOwners,
        SendToSecondaryOwners: config.sendToSecondaryOwners,
        AdditionalRecipients: config.additionalRecipients.join(', '),
        Priority: config.priority,
        Template: config.template
      };

      // Check if config exists
      const existingResponse = await fetch(
        `${this.baseUrl}/_api/web/lists/getbytitle('EmailConfigurations')/items?$filter=NotificationType eq '${config.notificationType}'&$select=Id`,
        {
          headers: { 'Accept': 'application/json; odata=verbose' }
        }
      );

      let response;
      if (existingResponse.ok) {
        const existingData = await existingResponse.json();
        if (existingData.d.results.length > 0) {
          // Update existing
          const itemId = existingData.d.results[0].Id;
          response = await fetch(
            `${this.baseUrl}/_api/web/lists/getbytitle('EmailConfigurations')/items(${itemId})`,
            {
              method: 'MERGE',
              headers: {
                'Accept': 'application/json; odata=verbose',
                'Content-Type': 'application/json; odata=verbose',
                'X-RequestDigest': requestDigest,
                'IF-MATCH': '*'
              },
              body: JSON.stringify(configData)
            }
          );
        }
      }
      
      if (!response) {
        // Create new
        response = await fetch(
          `${this.baseUrl}/_api/web/lists/getbytitle('EmailConfigurations')/items`,
          {
            method: 'POST',
            headers: {
              'Accept': 'application/json; odata=verbose',
              'Content-Type': 'application/json; odata=verbose',
              'X-RequestDigest': requestDigest
            },
            body: JSON.stringify(configData)
          }
        );
      }

      return response.ok;

    } catch (error) {
      console.error('Error saving email configuration:', error);
      return false;
    }
  }
}

export default EmailConfigurationService;
```

### **Enhanced Email Notification Service (Updated)**

```javascript
// services/EmailNotificationService.js - Enhanced Version
class EmailNotificationService {
  constructor() {
    this.baseUrl = 'https://teams.global.hsbc/sites/EmployeeEng';
    this.requestDigest = null;
    this.isInitialized = false;
    this.configService = new EmailConfigurationService(this.baseUrl);
  }

  // Enhanced procedure upload notification with configurable recipients
  async sendProcedureUploadedNotification(procedure, uploadedBy = null) {
    try {
      console.log(`üìß Sending upload notification for procedure: ${procedure.name}`);
      
      // Get email configuration for this notification type
      const config = await this.configService.getEmailConfig('procedure-uploaded');
      
      if (!config.enabled) {
        console.log('üìß Procedure upload notifications are disabled');
        return { success: true, message: 'Notifications disabled' };
      }

      // Build recipient list based on configuration
      const recipients = this.buildRecipientList(procedure, config);
      const ccList = this.buildCCList(procedure, config);
      const bccList = this.buildBCCList(procedure, config);

      console.log(`üìß Recipients: ${recipients.join(', ')}`);
      console.log(`üìß CC: ${ccList.join(', ')}`);
      console.log(`üìß BCC: ${bccList.join(', ')}`);

      // Get template and populate
      const template = await this.getTemplate('procedure-uploaded', config.template);
      const emailBody = this.populateTemplate(template, {
        procedureName: procedure.name,
        procedureId: procedure.id,
        uploadedBy: uploadedBy || procedure.uploaded_by || 'System',
        lob: procedure.lob,
        qualityScore: procedure.score || 'Not assessed',
        uploadDate: new Date().toLocaleDateString(),
        procedureUrl: `${this.baseUrl}/Lists/Procedures/DispForm.aspx?ID=${procedure.id}`,
        primaryOwner: procedure.primary_owner,
        secondaryOwner: procedure.secondary_owner || 'Not assigned'
      });

      // Send email
      const result = await this.sendEmail({
        to: recipients,
        cc: ccList,
        bcc: bccList,
        subject: `üìÑ New Procedure Uploaded: ${procedure.name}`,
        body: emailBody,
        priority: config.priority
      });

      // Log the notification
      await this.logNotification({
        type: 'procedure-uploaded',
        procedureId: procedure.id,
        procedureName: procedure.name,
        recipients: recipients,
        ccList: ccList,
        bccList: bccList,
        success: result.success
      });

      return result;

    } catch (error) {
      console.error('‚ùå Error sending procedure upload notification:', error);
      return { success: false, error: error.message };
    }
  }

  // Enhanced procedure deletion notification
  async sendProcedureDeletedNotification(procedure, deletedBy = null) {
    try {
      console.log(`üìß Sending deletion notification for procedure: ${procedure.name}`);
      
      const config = await this.configService.getEmailConfig('procedure-deleted');
      
      if (!config.enabled) {
        console.log('üìß Procedure deletion notifications are disabled');
        return { success: true, message: 'Notifications disabled' };
      }

      const recipients = this.buildRecipientList(procedure, config);
      const ccList = this.buildCCList(procedure, config);
      const bccList = this.buildBCCList(procedure, config);

      const template = await this.getTemplate('procedure-deleted', config.template);
      const emailBody = this.populateTemplate(template, {
        procedureName: procedure.name,
        procedureId: procedure.id,
        deletedBy: deletedBy || 'System Administrator',
        lob: procedure.lob,
        deleteDate: new Date().toLocaleDateString(),
        deleteTime: new Date().toLocaleTimeString(),
        primaryOwner: procedure.primary_owner,
        secondaryOwner: procedure.secondary_owner || 'Not assigned',
        reason: 'Administrative action'
      });

      const result = await this.sendEmail({
        to: recipients,
        cc: ccList,
        bcc: bccList,
        subject: `üóëÔ∏è Procedure Deleted: ${procedure.name}`,
        body: emailBody,
        priority: config.priority
      });

      await this.logNotification({
        type: 'procedure-deleted',
        procedureId: procedure.id,
        procedureName: procedure.name,
        recipients: recipients,
        ccList: ccList,
        bccList: bccList,
        success: result.success
      });

      return result;

    } catch (error) {
      console.error('‚ùå Error sending procedure deletion notification:', error);
      return { success: false, error: error.message };
    }
  }

  // Enhanced expiry warning with different configs per timeframe
  async sendExpiryWarningNotification(procedure, daysUntilExpiry) {
    try {
      // Determine notification type based on days until expiry
      let notificationType;
      if (daysUntilExpiry >= 30) {
        notificationType = 'expiry-30-days';
      } else if (daysUntilExpiry >= 10) {
        notificationType = 'expiry-10-days';
      } else {
        notificationType = 'expiry-urgent';
      }

      console.log(`üìß Sending ${notificationType} notification for procedure: ${procedure.name}`);
      
      const config = await this.configService.getEmailConfig(notificationType);
      
      if (!config.enabled) {
        console.log(`üìß ${notificationType} notifications are disabled`);
        return { success: true, message: 'Notifications disabled' };
      }

      const recipients = this.buildRecipientList(procedure, config);
      const ccList = this.buildCCList(procedure, config);
      const bccList = this.buildBCCList(procedure, config);

      const urgencyLevel = this.getUrgencyLevel(daysUntilExpiry);
      const template = await this.getTemplate(`expiry-warning-${urgencyLevel}`, config.template);
      
      const emailBody = this.populateTemplate(template, {
        procedureName: procedure.name,
        procedureId: procedure.id,
        daysUntilExpiry: daysUntilExpiry,
        expiryDate: new Date(procedure.expiry).toLocaleDateString(),
        primaryOwner: procedure.primary_owner,
        secondaryOwner: procedure.secondary_owner || 'Not assigned',
        lob: procedure.lob,
        urgencyLevel: urgencyLevel,
        procedureUrl: `${this.baseUrl}/Lists/Procedures/DispForm.aspx?ID=${procedure.id}`,
        actionRequired: daysUntilExpiry <= 5 ? 'IMMEDIATE ACTION REQUIRED' : 'Please review and update',
        priorityLevel: config.priority
      });

      const subjectPrefix = daysUntilExpiry <= 0 ? 'üö® EXPIRED' : 
                           daysUntilExpiry <= 5 ? '‚ö†Ô∏è URGENT' : 'üìÖ';

      const result = await this.sendEmail({
        to: recipients,
        cc: ccList,
        bcc: bccList,
        subject: `${subjectPrefix} Procedure Expiry: ${procedure.name} (${daysUntilExpiry} days)`,
        body: emailBody,
        priority: config.priority
      });

      await this.logNotification({
        type: notificationType,
        procedureId: procedure.id,
        procedureName: procedure.name,
        daysUntilExpiry: daysUntilExpiry,
        recipients: recipients,
        ccList: ccList,
        bccList: bccList,
        success: result.success
      });

      return result;

    } catch (error) {
      console.error('‚ùå Error sending expiry warning notification:', error);
      return { success: false, error: error.message };
    }
  }

  // Build recipient list based on configuration
  buildRecipientList(procedure, config) {
    const recipients = [];

    // Add primary owner if configured
    if (config.sendToOwners && procedure.primary_owner_email) {
      recipients.push(procedure.primary_owner_email);
    }

    // Add secondary owner if configured
    if (config.sendToSecondaryOwners && procedure.secondary_owner_email) {
      recipients.push(procedure.secondary_owner_email);
    }

    // Add additional recipients from config
    if (config.additionalRecipients) {
      recipients.push(...config.additionalRecipients);
    }

    return [...new Set(recipients)]; // Remove duplicates
  }

  // Build CC list with LOB-specific CCs
  buildCCList(procedure, config) {
    const ccList = [];

    // Add global CC list
    if (config.ccList) {
      ccList.push(...config.ccList);
    }

    // Add LOB-specific CC list
    if (config.lobSpecificCC && config.lobSpecificCC[procedure.lob]) {
      ccList.push(...config.lobSpecificCC[procedure.lob]);
    }

    return [...new Set(ccList)]; // Remove duplicates
  }

  // Build BCC list with LOB-specific BCCs
  buildBCCList(procedure, config) {
    const bccList = [];

    // Add global BCC list
    if (config.bccList) {
      bccList.push(...config.bccList);
    }

    // Add LOB-specific BCC list
    if (config.lobSpecificBCC && config.lobSpecificBCC[procedure.lob]) {
      bccList.push(...config.lobSpecificBCC[procedure.lob]);
    }

    return [...new Set(bccList)]; // Remove duplicates
  }

  // Enhanced email sending with priority support
  async sendEmail(emailOptions) {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      const emailPayload = {
        properties: {
          __metadata: { type: 'SP.Utilities.EmailProperties' },
          To: { results: emailOptions.to },
          CC: emailOptions.cc && emailOptions.cc.length > 0 ? { results: emailOptions.cc } : { results: [] },
          BCC: emailOptions.bcc && emailOptions.bcc.length > 0 ? { results: emailOptions.bcc } : { results: [] },
          Subject: emailOptions.subject,
          Body: emailOptions.body,
          From: emailOptions.from || 'noreply@hsbc.com'
        }
      };

      // Add priority if specified
      if (emailOptions.priority && emailOptions.priority !== 'Normal') {
        emailPayload.properties.Priority = emailOptions.priority;
      }

      const response = await fetch(`${this.baseUrl}/_api/SP.Utilities.Utility.SendEmail`, {
        method: 'POST',
        headers: {
          'Accept': 'application/json; odata=verbose',
          'Content-Type': 'application/json; odata=verbose',
          'X-RequestDigest': this.requestDigest
        },
        body: JSON.stringify(emailPayload)
      });

      if (response.ok) {
        console.log('‚úÖ Email sent successfully via SharePoint');
        return { 
          success: true, 
          timestamp: new Date().toISOString(),
          recipients: emailOptions.to.length,
          cc: emailOptions.cc?.length || 0,
          bcc: emailOptions.bcc?.length || 0
        };
      } else {
        throw new Error(`Email send failed: ${response.status}`);
      }

    } catch (error) {
      console.error('‚ùå Email send error:', error);
      return { success: false, error: error.message };
    }
  }

  // Log notification for audit trail
  async logNotification(notificationData) {
    try {
      const logEntry = {
        __metadata: { type: 'SP.Data.EmailNotificationLogListItem' },
        Title: `${notificationData.type}: ${notificationData.procedureName}`,
        NotificationType: notificationData.type,
        ProcedureId: notificationData.procedureId,
        ProcedureName: notificationData.procedureName,
        Recipients: notificationData.recipients.join('; '),
        CCList: notificationData.ccList.join('; '),
        BCCList: notificationData.bccList.join('; '),
        SentAt: new Date().toISOString(),
        Success: notificationData.success,
        DaysUntilExpiry: notificationData.daysUntilExpiry || null
      };

      await fetch(`${this.baseUrl}/_api/web/lists/getbytitle('EmailNotificationLog')/items`, {
        method: 'POST',
        headers: {
          'Accept': 'application/json; odata=verbose',
          'Content-Type': 'application/json; odata=verbose',
          'X-RequestDigest': this.requestDigest
        },
        body: JSON.stringify(logEntry)
      });

    } catch (error) {
      console.warn('Could not log notification:', error);
    }
  }

  // Rest of the methods (initialize, getTemplate, populateTemplate, etc.) remain the same...
}

export default EmailNotificationService;
```

This enhanced system now provides:

‚úÖ **Configurable Recipients**: Primary + Secondary owners + Admin-defined lists  
‚úÖ **Tailored CC/BCC**: Different lists for each email type and LOB  
‚úÖ **Flexible Configuration**: Each notification type has its own settings  
‚úÖ **Audit Trail**: Complete logging of all sent notifications  
‚úÖ **Priority Support**: High/Normal priority emails

Would you like me to continue with **Phase 4: The React Admin Interface** for managing all these email configurations? üöÄ‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã






